前言

+  ***之前学`c++`完全是学到哪算哪，从来没有系统性学过，现在重新开始。有些重点借此记录下来，希望能坚持下来，有所收获。***

  

## 1. 变量

### 1.1 常量——`#define`和`const`

+ `#define` (宏定义)：它在编译的预处理阶段起作用，只是简单的字符替换，没有类型检查，在哪使用就在哪被替换，内存中有若干个备份，且不能进行调试。
+ `const`：它在程序编译和运行阶段起作用，有对应的数据类型，会进行类型检查，在内存中只有一份备份，节省了内存空间，可以进行调试。
  
  
### 1.2 标识符

+ 标识符不能是关键字
+ 标识符只能由字母、数字、下划线构成
+ 第一个字符必须是字母或下划线
+ 标识符区分大小写
  
  
### 1.3 数据类型
+ 数据类型的意义：为变量分配合适的内存空间。
  
  
#### 1.3.1 整形
|数据类型|占用空间|表示范围|
|---|---|---|
|short(短整型)|2字节|-2^15 ~ 2^15-1|
|int(整型)|4字节|-2^31 ~ 2^31-1|
|long(长整型)|windows4字节, Linux为4字节（32位）,8字节（64位）|-2^31 ~ 2^31-1|
|long long(长长整型)|8字节|-2^63 ~ 2^63-1|



#### 1.3.2 浮点型（实型）
|数据类型|占用空间|表示范围|
|---|----|---|
|float(单精度)|4字节|7位有效数字|
|double(双精度)|8字节|15~16位有效数字|



#### 1.3.3 字符型
+ `char`字符型，占用一个字节，在内存中存储的是其对应的ASCIII码，常见的ASCII码有
   A—65，a—97。



#### 1.3.4 字符串
- `char[]`
- `string` : 需要包含头文件<string>



####  1.3.5 布尔类型
- true
- false



### 1.4 运算符
| 运算符 | 术语 | 示例 | 结果 |
| ------ | ---- | ---- | ---- |
|`%`|取模（取余）|10%3|1|
|`++`|前置++|a=2,b=++a|a=3,b=3|
|`++`|后置++|a=2,b=a++|a=3,b=2|
|`+=`|加等于|a=2,a+=3|a=5|
|`&`|逻辑‘与’|a=0&a++|false,a=1|
|`&&`|逻辑'与'（有短路）|a=0&&a++|a=0|
|`&`|位运算符|0x31&0x0f|0x01|
|`|`|逻辑‘或’|`a=1|a++`|a=2|
|`||`|逻辑'或'(有短路)|`a=1||a++`|a=1|
|`（?:）`|三目运算符|`a= (10<5?3:2)`|a=2|




## 2. 指针

### 2.1 指针大小
+ 32位操作系统占4字节
+ 64位操作系统占8字节



### 2.2 const修饰指针
|类型|示例|特点|
|---|---|---|
|常量指针|`const int* p = &a`|指针指向的值不能修改，指针的指向可以修改|
|指针常量|`int* const p = &a`|指针的指向不能修改，指向的值可以修改|
|——|`const int* const p = &a`|指针的指向不能修改，指向的值也不能修改|



## 3.结构体



## 4.内存分区模型
+ c++在程序运行前分为代码区和全局区
|类型|特点|回收机制|
|---|---|---|
|代码区|共享只读|——|
|全局区|存放全局变量，静态变量，字符串常量和全局常量|由操作系统回收|

+ c++在编译和运行时分为栈区和堆区
|类型|特点|回收机制|
|---|---|---|
|栈区|存放函数的参数值和局部变量，不要返回局部变量的地址|由编译器自动分配和释放|
|堆区|利用new在堆区开辟内存|程序员分配释放，若程序员不释放（delete），结束后操作系统回收|



## 5. 引用
+ 引用的本质是指针，简化指针的操作




## 6. 类和对象
+ 面向对象的核心是：封装、继承、多态



### 6.1 封装
#### 6.1.1 封装的权限
|类型|特点|
|---|---|
|public|内部和外部都可以访问|
|protected|内部可以访问，外部不可以访问，其子类可以访问|
|private|内部可以访问，外部不可以访问，其子类也不能访问|
+ struct默认权限公开，而Class默认私有



#### 6.1.2 构造函数
+ 无参构造
+ 有参构造
+ 拷贝构造 `const`修饰的引用
|类型|特点|
|---|---|
|浅拷贝|编译器完成的简单赋值操作，可能造成堆区内存的重复释放|
|深拷贝|在堆区重新开辟一块空间|



#### 6.1.3 析构函数
+ 释放堆区的内存 


#### 6.1.4 初始化列表
`Student(int a , string b, int c) : id(a) : name(b) : age(c){}`



#### 6.1.5 静态成员变量和静态成员函数
+ 在编译阶段分配内存
+ 类内声明，类外初始化
+ 所有对象共享一份数据

+ 所有对象共用一个函数
+ 静态成员函数只能访问静态成员变量

+ 空类占一个字节
+ 非静态成员变量属于类



#### 6.1.6 this 指针
+ 本质是一个常量指针
+ 指向被调用的成员函数所属对象
+ 区分重名的成员变量和形参
+ 在非静态成员函数中返回对象本身` return *this`


#### 6.1.7 常函数和常对象

+ 常函数在函数后加const修饰
+ 常函数不能修改成员变量，如果要修改，成员变量需要用mutable修饰
+ 常对象在定义时用const修饰
+ 常对象只能调用常函数

~~~c++
Class Student{
	public:
	void goToSchool() const {
		cout << name << endl;
	}
	
	private:
	mutable string name;
}

const Student s;
~~~



#### 6.1.8 友元
+ 全局函数做友元，在类中声明函数并用`friend`修饰
+ 类做友元，在类中声明类并用`friend`修饰
+ 成员函数做友元，在类中声明成员函数并用`friend`修饰



#### 6.1.9 运算符重载
自定义数据类型的运算
+ 加号重载：`operator+()`，可以在成员函数也可以在全局函数
+ 左移重载：`operator<<()`, 在全局函数
+ 自增重载： `operator++()` ,在成员函数，用`int`占位符区分后置++；前置返回对象引用，后置返回新对象
+ 赋值重载：`operator=()`,在成员函数，深拷贝解决堆区内存重复释放
+ 函数调用重载：`operator()()`,又称防函数



### 6.2 继承

> class 子类 ： public/protected/private 父类
> 继承中先构造父类再构造子类，析构顺序相反
> 子类属性和父类属性重名，访问父类属性需要加作用域



#### 6.2.1 继承方式
+ public：父类私有属性不能访问，其他属性权限保持不变
+ protected：父类私有属性不能访问，其他属性权限全变成protected
+ private：父类私有属性不能访问，其他属性权限全变成private




### 6.3 多态
> 静态多态：编译时绑定地址
> 动态多态：运行时绑定地址

> 多态的条件：构成继承关系，子类重写父类虚函数`virtual`
> 多态使用：父类指针或引用指向子类对象
> 多态好处：
> + 代码可读性强
> + 扩展性强
> 

#### 6.3.1 纯虚函数与抽象类
+ `virtual void 函数名（参数） = 0` 
+ 有一个纯虚函数则构成抽象类，不能实例化

#### 6.3.2 虚析构和纯虚析构
+ 解决父类指针释放子类对象
+ 都需要具体的函数实现



## 7 文件操作

### 7.1 文本文件读写
+ 导入头文件`fstream`
+ 文件打开方式
|打开方式|解释|
|---|---|
|ios::in|读文件|
|ios::out|写文件|
|ios::ate|初始位置：文件尾|
|ios::app|追加方式写文件|
|ios::trunc|如果文件存在，先删除再创建|
|ios::binary|二进制方式|

### 7.2 二进制读写
+ 读：`read()`
+ 写：`write()`



## 8 泛型编程和STL

### 8.1 模板

#### 8.1.1 函数模板
~~~c++
template<typename T>
//函数体或函数声明
~~~
> 使用方式
> + 自动类型推导,不会发生隐式类型转换
> + 指定类型,会发生隐式类型转换
> 
> 函数模板与普通函数重载调用
> + 两者都可以实现,优先调用普通函数.
> + 通过空模板函数列表强制调用模板函数
> + 函数模板可以重载
> + 如果函数模板可以产生更好的匹配,那么调用函数模板
> 

#### 8.1.2 类模板
~~~c++
template<typename T1, typename T2>
class Person{
public:
	T1 name;
	T2 age;
}
~~~
+ 类模板只能指定类型,且可以有默认参数


### 8.2 STL
> + STL(standard template library) 六大组件:容器, 算法, 迭代器, 仿函数, 适配器, 空间配置器
> 
> > 容器
> > + 序列式容器:强调值的排序,每个元素都有固定的位置
> > + 关联式容器:二叉树结构,每个元素没有物理上的顺序关系
> > 算法
> > + 质变算法:改变了区间元素的内容,比如拷贝, 替换
> > + 非质变算法:不会改变区间元素的内容,比如查找,计数
> > 迭代器
> > + 双向迭代器:读写操作,并能向前向后操作
> > + 随机访问迭代器:读写操作,可以跳跃式访问任何数据
> > 


#### 8.2.1 容器
+ vector容器
~~~c++
vector<int> v;
v.push_back(10);
v.pop_back();
vector<int>::iterator it = v.begin();
v.reserve(1000);	//预留空间
v.insert(v.begin(), 10);
~~~

+ deque 容器
  支持前插和后插，内部通过中控器维护
~~~c++
deque<int> d;
d.push_front(10);
d.pop_front();
d.push_back(10);
d.pop_back();
~~~

+ stack 容器
  先进后出，不能进行遍历
~~~c++
stack<int> s;
s.empty();
s.size();
s.push();
s.pop();
s.top();
~~~
+ queue 容器
  